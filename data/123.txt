
AES 解密需要以下幾個東西：

密鑰：AES 使用密鑰來加密和解密資料。密鑰必須是相同的，才能成功解密資料。
加密資料：AES 加密的資料。
解密器：AES 解密器是用來解密資料的軟體或硬體。
在 Python 中，您可以使用 import Crypto.Cipher 匯入 AES 模組。然後，您可以使用 AES.new() 方法建立一個 AES 解密器。解密器需要指定密鑰和模式。

以下是 AES 解密的範例：

Python
import base64
import os
import sys

from Crypto.Cipher import AES

# 讀取密鑰
with open("key.txt", "r") as f:
    key = f.read().strip()

# 讀取加密資料
ciphertext = base64.b64decode(encrypt)

# 建立解密器
cipher = AES.new(key, AES.MODE_CBC)

# 解密資料
plaintext = cipher.decrypt(ciphertext)

# 輸出解密資料
print(plaintext)
請謹慎使用程式碼。瞭解詳情
這段程式碼將會使用之前生成的密鑰來解密加密資料。

在本例中，我們使用 base64.b64decode() 方法將加密資料轉換回原始格式。然後，我們使用 AES.new() 方法建立一個 AES 解密器，使用給定的密鑰和模式。最後，我們使用 cipher.decrypt() 方法來解密加密資料。

解密資料後，您可以將其使用。

以下是使用 AES 解密資料的步驟：

生成密鑰。

使用密鑰來加密資料。

將加密資料轉換為 Base64 格式。

將加密資料儲存到檔案中，或將其傳輸到另一個系統。

要解密資料，需要使用相同的密鑰。

以下是使用 AES 解密資料的注意事項：

密鑰必須足夠長才能保證安全。
加密資料後，您應該將密鑰妥善保管。
在傳輸加密資料時，您應該使用安全的通道。
在實際開發中，可以根據需求來調整加密和解密的資料。

個人資料相片
程式:
        try:
            data = bytes(data,encoding="utf-8")
        except:
            pass
        with open(f"{username}/prikey.pem","rb") as file:
            read = b64decode(file.read())
        rsakey = rsa.PrivateKey.load_pkcs1(read)
        #---------------AES----------------------
        with open(f"{username}/aes.txt","rb") as file:
            key = b64decode(file.read())
        text = AES.new(key,AES.MODE_CBC)
        aes = text.decrypt(dat

錯誤馬
Traceback (most recent call last):
  File "d:\Password_Library\data\encryption.py", line 79, in <module>
    decrypt = Decrypt("Justmore5mins",encrypt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "d:\Password_Library\data\encryption.py", line 70, in __init__
    aes = text.decrypt(data)
          ^^^^^^^^^^^^^^^^^^
  File "C:\Users\user\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\Crypto\Cipher\_mode_cbc.py", line 246, in decrypt
    raise ValueError("Data must be padded to %d byte boundary in CBC mode" % self.block_size)
ValueError: Data must be padded to 16 byte boundary in CBC mode
查看其他草稿













The error message "Data must be padded to 16 byte boundary in CBC mode" indicates that the data being decrypted is not padded correctly. AES encryption requires that the data be padded to a multiple of the block size, which is 16 bytes in CBC mode. The AES.new() function automatically pads the data for you when you encrypt it, but you need to manually pad the data before you decrypt it.

To fix the error, you need to pad the data before you decrypt it. You can do this using the PKCS7 padding scheme. Here is an example of how to do this:

Python
from Crypto.Util.Padding import pad
from Crypto.Cipher import AES

# Read the encrypted data
with open("encrypted.data", "rb") as f:
    encrypted_data = f.read()

# Load the key
with open("key.pem", "rb") as f:
    key = f.read()

# Pad the data
padded_data = pad(encrypted_data, AES.block_size)

# Decrypt the data
cipher = AES.new(key, AES.MODE_CBC)
decrypted_data = cipher.decrypt(padded_data)

# Unpad the data
unpadded_data = unpad(decrypted_data, AES.block_size)

print(unpadded_data)
請謹慎使用程式碼。瞭解詳情
This code will first read the encrypted data from a file. Then, it will load the key from a file. Next, it will pad the data using the PKCS7 padding scheme. Finally, it will decrypt the data and print it to the console.

Here is the complete code:

Python
import rsa
import b85encode
from Crypto.Util.Padding import pad
from Crypto.Cipher import AES

def decrypt(username, data):
    with open(f"{username}/prikey.pem", "rb") as file:
        read = b64decode(file.read())
    rsakey = rsa.PrivateKey.load_pkcs1(read)

    # Decrypt the data using RSA
    decrypted_data = rsa.decrypt(data, rsakey)

    # Pad the data
    padded_data = pad(decrypted_data, AES.block_size)

    # Load the AES key
    with open(f"{username}/aes.txt", "rb") as file:
        key = b64decode(file.read())

    # Decrypt the data using AES
    cipher = AES.new(key, AES.MODE_CBC)
    aes = cipher.decrypt(padded_data)

    # Unpad the data
    unpadded_data = unpad(aes, AES.block_size)

    return unpadded_data.decode('utf-8')

if __name__ == "__main__":
    username = "Justmore5mins"
    encrypt = "Hello, world!"
    decrypted = decrypt(username, encrypt)
    print(decrypted)